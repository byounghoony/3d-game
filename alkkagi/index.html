<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>3D 알까기 게임 완전판</title>
<style>
/* 기본 화면 스타일 설정 */
body { margin:0; overflow:hidden; font-family:sans-serif; }

/* UI 영역 위치와 스타일 */
#ui { position:absolute; top:10px; left:10px; z-index:10; }
#turn { margin-top:10px; font-weight:bold; }
#info { margin-top:5px; }
#score { margin-top:5px; font-weight:bold; }

/* 게이지 바 컨테이너 숨김 상태 */
#chargeBarContainer {
    position: absolute; /* 화면상에 자유롭게 위치 */
    width: 100px;
    height: 15px;
    background: #555;
    border: 1px solid #fff;
    display: none; /* 초기에는 숨김 */
}
#chargeBar { width:0%; height:100%; background:#f00; border-radius:5px; }

/* 미니맵 캔버스 위치 */
#minimap { position:absolute; top:10px; right:10px; width:200px; height:200px; border:2px solid #000; }

/* 버튼 기본 스타일 */
button { margin:5px; padding:5px 10px; }

/* 승리 표시 영역 숨김 상태 */
#winner { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:24px; font-weight:bold; display:none; background:rgba(255,255,255,0.8); padding:10px; border-radius:10px; }
</style>
</head>
<body>
<!-- UI 영역 -->
<div id="ui">
  플레이어1: <input id="p1" placeholder="닉네임"><br>
  플레이어2: <input id="p2" placeholder="닉네임"><br>
  <button id="startBtn">게임 시작</button>
  <div id="turn"></div>
  <div id="info"></div>
  <div id="score"></div>
  <div id="chargeBarContainer"><div id="chargeBar"></div></div>
  <button id="chargeBtn" disabled>치기 준비</button>
  <button id="hitBtn" disabled>치기!</button>
</div>

<!-- 미니맵 캔버스 -->
<canvas id="minimap"></canvas>

<!-- 승리 메시지 영역 -->
<div id="winner"></div>

<script type="module">
/* Three.js 모듈 임포트: 3D 그래픽 처리 */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

/* Cannon-es 모듈 임포트: 물리 엔진 */
import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

/* Tween.js 모듈 임포트: 애니메이션/보간 처리 */
import { Tween, Easing, update as TWEENUpdate } from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

/* OrbitControls: 카메라 회전/줌 컨트롤 */
import { OrbitControls } from './js/OrbitControls.js';

import { RGBELoader } from './js/RGBELoader.js';

/* ====== 변수 선언 ====== */
let scene, camera, renderer, world; // 씬, 카메라, 렌더러, 물리 월드
let stones = [], selectedStone = null; // 돌 배열, 선택된 돌
let players = [], knockedOutOpponentStoneThisTurn = false; // 플레이어 배열, 이번 턴에 상대방 돌을 쳤는지 여부
let turn = 0, chargePower = 0, charging = false; // 턴, 게이지 충전 상태
let stoneRadius = 0.3; // 돌 반지름
let isTurnPlaying = false; // 현재 턴이 진행 중인지 여부
let raycaster, mouse; // 마우스 클릭 처리
let miniRenderer, miniCamera; // 미니맵 렌더러, 카메라
let tween; // Tween.js 객체
let arrowHelper; // 발사 방향을 보여주는 화살표
let controls; // OrbitControls
let scores = [0,0]; // 점수
let lastTime; // 물리 엔진 업데이트용
const boardSize = 18; // 바둑판 크기
const halfSize = (boardSize - 1)/2;

/* ====== UI 요소 가져오기 ====== */
const p1Input = document.getElementById('p1');
const p2Input = document.getElementById('p2');
const startBtn = document.getElementById('startBtn');
const turnDiv = document.getElementById('turn');
const infoDiv = document.getElementById('info');
const scoreDiv = document.getElementById('score');
const chargeBtn = document.getElementById('chargeBtn');
const hitBtn = document.getElementById('hitBtn');
const winnerDiv = document.getElementById('winner');
const chargeBarContainer = document.getElementById('chargeBarContainer');
const chargeBar = document.getElementById('chargeBar');

/* ====== 닉네임 입력 체크 ====== */
[p1Input,p2Input].forEach(input=>{
  input.addEventListener('input',()=>{ 
    // 둘 다 입력하면 게임 시작 버튼 활성화
    // startBtn.disabled = !(p1Input.value && p2Input.value); 
  });
});

/* ====== 초기화 함수 ====== */
function init(){
    // 씬 생성, 배경색
    scene = new THREE.Scene(); 
    scene.background = new THREE.Color(0x87CEEB); // 하늘색

    new RGBELoader().load('./hdr/space.hdr', (texture) => {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      scene.background = texture; // 씬의 배경으로 설정
      scene.environment = texture; // 모든 PBR 재질의 환경광 및 반사 맵으로 설정
    });

    // 카메라 생성
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0,10,10); // 카메라 위치
    camera.lookAt(0,0,0); // 카메라 타겟

    // 렌더러 생성
    renderer = new THREE.WebGLRenderer({antialias:true}); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    document.body.appendChild(renderer.domElement); // DOM에 붙이기

    // OrbitControls 생성
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false; // 이동 막기
    controls.enableZoom = true; // 줌 가능
    controls.update();

    // Cannon.js 물리 월드 생성
    world = new CANNON.World({ gravity:new CANNON.Vec3(0, 0, 0) }); // 중력은 필요할 때 돌에만 개별 적용
    world.broadphase = new CANNON.NaiveBroadphase(); // 충돌 체크 방식
    world.solver.iterations = 300; // 물리 계산 반복 횟수 (정확도 향상)

    // Three.js 바닥 메쉬
    const textureLoader = new THREE.TextureLoader();
    const groundTexture = textureLoader.load('./wood3.jpg'); // wood.jpg 텍스처 로드
    const gMesh = new THREE.Mesh(
        new THREE.BoxGeometry(boardSize, 5, boardSize),
        new THREE.MeshStandardMaterial({map: groundTexture, roughness:0.5, metalness:0.1}) // map 속성에 텍스처 적용
        // new THREE.MeshStandardMaterial({color:0xdeb887, roughness:0.9, metalness:0})
    );
    gMesh.position.set(0, -2.5,0);
    scene.add(gMesh);

    // Cannon.js 바닥 물리
    const groundMaterial = new CANNON.Material('groundMat');
    const groundBody = new CANNON.Body({
        mass:0, // 고정
        shape:new CANNON.Box(new CANNON.Vec3(boardSize/2,0.1,boardSize/2)),
        material:groundMaterial
    });
    groundBody.position.set(0,-0.1,0);
    world.addBody(groundBody);

    // ====== 바둑판 선 그리기 ======
    const lineMat = new THREE.LineBasicMaterial({color:0x000, linewidth: 2}); // 선 색 및 두께 설정
    const lineGeo = new THREE.BufferGeometry(); // 선 지오메트리
    const positions=[];

    const count = (halfSize * 2);   // 원래 간격 수
    const step = (halfSize * 2) / (count + 1); // 새 간격 (한 줄 더 추가)

    // 가로선
    for(let i=0; i<=count+1; i++){ 
        let z = -halfSize + i * step;
        positions.push(-halfSize,0.01,z, halfSize,0.01,z);
    }

    // 세로선
    for(let j=0; j<=count+1; j++){ 
        let x = -halfSize + j * step;
        positions.push(x,0.01,-halfSize, x,0.01,halfSize);
    }
    lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
    scene.add(new THREE.LineSegments(lineGeo,lineMat));

    // ====== 조명 ======
    const light = new THREE.DirectionalLight(0xffffff,3.5); 
    light.position.set(10,20,10); 
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x888888)); // 환경광

    // ====== 미니맵 ======
    miniRenderer = new THREE.WebGLRenderer({canvas:document.getElementById('minimap')});
    miniRenderer.setSize(200,200);

    miniCamera = new THREE.OrthographicCamera(-10,10,10,-10,0,30);
    miniCamera.position.set(0,20,0); 
    miniCamera.lookAt(0,0,0);

    // ====== 마우스 처리 ======
    raycaster = new THREE.Raycaster(); 
    mouse = new THREE.Vector2();

    // ====== 디버그용 화살표 ======
    arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 3, 0xff0000);
    arrowHelper.visible = false; // 처음에는 숨김
    scene.add(arrowHelper);

    // ====== 이벤트 ======
    window.addEventListener('resize',onWindowResize); // 창 크기 변경 시
    renderer.domElement.addEventListener('pointerdown',onPointerDown); // 클릭 이벤트
}

/* ====== 게임 시작 버튼 클릭 ====== */
startBtn.addEventListener('click',()=>{
    // 플레이어 정보 생성
    players=[
        {name:p1Input.value, color:0x000000, stones:[], outCount:0},
        {name:p2Input.value, color:0xffffff, stones:[], outCount:0}
    ];
    startBtn.disabled=true; // 버튼 비활성화
    p1Input.disabled=true; p2Input.disabled=true; // 입력 막기
    createStones(); // 돌 생성
    updateTurnUI(); // UI 업데이트
    chargeBtn.disabled=false; // 준비 버튼 활성화
});

/* ====== 알(돌) 생성 ====== */
function createStones(){
    const stoneMat = new CANNON.Material('stoneMat'); // 돌 재질
    const groundMaterial = world.bodies.find(b => b.material && b.material.name === 'groundMat').material; // 바닥 재질 가져오기

    // 돌과 바닥의 상호작용 설정
    const stoneGroundContact = new CANNON.ContactMaterial(stoneMat, groundMaterial,{
        friction: 0.01, restitution: 0.1 // 마찰력과 반발력 조정
    });
    world.addContactMaterial(stoneGroundContact);

    // 돌과 돌의 상호작용 설정
    world.addContactMaterial(new CANNON.ContactMaterial(stoneMat, stoneMat, { friction: 0.01, restitution: 1 }));

    const count=8, spacing=1.9; // 돌 개수, 간격
    const positions=[ {xStart:-halfSize+1,playerIndex:0}, {xStart:halfSize-1,playerIndex:1} ]; // 양쪽 플레이어 시작 위치

    positions.forEach(p=>{
        const {xStart,playerIndex}=p;
        const color = players[playerIndex].color;

        for(let i=0;i<count;i++){
            const x = xStart;
            const z = (i - (count - 1) / 2) * spacing;

            // Three.js 돌 메쉬
            const geo = new THREE.SphereGeometry(stoneRadius,32,32);
            geo.scale(1,0.4,1); // 약간 납작하게
            const mesh = new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:color, roughness:0.3, metalness:0.1, emissive:0x000}));
            mesh.position.set(x, 0.1, z); // 바닥에 붙도록 y 위치 조정
            scene.add(mesh);

            // Cannon.js 돌 물리
            const body = new CANNON.Cylinder(stoneRadius,stoneRadius,stoneRadius*0.4,16);
            const cannonBody = new CANNON.Body({
                mass:0.8, // 무게
                shape:body,
                position:new CANNON.Vec3(x, 0.1, z), // 바닥에 붙도록 y 위치 조정
                material:stoneMat,
                linearDamping:0.99, // 속도 감쇠 (공기 저항처럼 작용)
                angularDamping:1 // 회전 감쇠
            });

            cannonBody.linearFactor.set(1, 0, 1);  // y축 이동 막기
            cannonBody.angularFactor.set(0,0,0); // 회전 제거(원하면 굴러가게 바꿀 수 있음)
            world.addBody(cannonBody);

            // 터널링 현상 방지를 위한 CCD(연속 충돌 감지) 설정
            cannonBody.ccdSpeedThreshold = 5; // 속도가 5 이상일 때 CCD 활성화
            cannonBody.ccdSweptSphereRadius = stoneRadius; // CCD에 사용할 구체의 반경

            // 연결
            mesh.userData.body = cannonBody;
            mesh.userData.player = playerIndex;
            stones.push(mesh);
            players[playerIndex].stones.push(mesh);
        }
    });
}

/* ====== UI 업데이트 함수 ====== */
function updateTurnUI(){ 
    turnDiv.textContent = `턴: ${players[turn].name}`; 
    updateInfoUI(); 
    updateScoreUI(); 
}
function updateInfoUI(){ 
    infoDiv.textContent = `${players[0].name}: ${players[0].stones.length}개 남음 / ${players[1].name}: ${players[1].stones.length}개 남음`; 
}
function updateScoreUI(){ 
    scoreDiv.textContent = `점수: ${players[0].name} ${scores[0]}점 / ${players[1].name} ${scores[1]}점`; 
}

/* ====== 마우스 클릭 처리 ====== */
function onPointerDown(event){
    if(!players[turn] || !players[turn].stones || isTurnPlaying) return;

    // 마우스 좌표를 -1~1 범위로 변환
    mouse.x = (event.clientX/window.innerWidth)*2-1;
    mouse.y = -(event.clientY/window.innerHeight)*2+1;

    raycaster.setFromCamera(mouse,camera); // 레이캐스터 설정

    const valid = players[turn].stones; // 현재 턴 플레이어의 돌만 선택 가능
    if(valid.length===0) return;

    const intersects = raycaster.intersectObjects(valid); // 클릭한 돌 확인
    if(intersects.length>0){
        if(selectedStone) selectedStone.material.emissive.setHex(0x000); // 이전 돌 색 해제
        selectedStone = intersects[0].object; // 선택 돌
        selectedStone.material.emissive.setHex(0x00ff00); // 선택 표시

        // 카메라 위치 이동
        // Tween.js를 사용하여 부드럽게 이동
        const pos = selectedStone.position.clone();
        new Tween(camera.position)
            .to({x:pos.x, y:pos.y+2, z:pos.z+5}, 500)
            .easing(Easing.Cubic.Out).start();

        new Tween(controls.target)
            .to({x:pos.x, y:pos.y, z:pos.z}, 500)
            .easing(Easing.Cubic.Out).start();
    }
}

/* ====== 게이지 충전 ====== */
chargeBtn.addEventListener('click',()=>{
    if(!selectedStone || charging) return;

    charging=true; 
    chargePower=0; 
    chargeBarContainer.style.display='block'; // 게이지 표시

    const obj={val:0};
    tween = new Tween(obj)
        .to({val:1},500)
        .easing(Easing.Linear.None)
        .yoyo(true)
        .repeat(Infinity)
        .onUpdate(()=>{ 
            chargePower = obj.val; 
            chargeBar.style.width=`${chargePower*100}%`; 
        })
        .start();

    hitBtn.disabled=false; // 치기 버튼 활성화
});

/* ====== 알 치기 ====== */
hitBtn.addEventListener('click', () => {
    if (!selectedStone || !charging) return;

    charging = false;
    tween.stop();
    hitBtn.disabled = true;
    chargeBarContainer.style.display = 'none';
    selectedStone.material.emissive.setHex(0x000);

    knockedOutOpponentStoneThisTurn = false; // 턴 시작 시 초기화
    const body = selectedStone.userData.body;
    if (!body) return;

    // 카메라 방향 (XZ 평면)
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();
    
    // 힘 적용
    const force = 60 * chargePower; // 게이지에 따라 힘 크기
    body.applyImpulse(new CANNON.Vec3(dir.x * force, 0, dir.z * force), body.position);

    selectedStone = null;
    isTurnPlaying = true; // 턴 진행 시작
    chargeBtn.disabled = true; // '치기 준비' 버튼 비활성화
});

/* ====== 돌 제거 함수 ====== */
function removeStone(stone) {
    const owner = stone.userData.player;
    if (owner !== turn) {
        scores[turn] += 1; // 상대 돌이면 점수 증가
        knockedOutOpponentStoneThisTurn = true; // 상대 돌을 떨어뜨렸다고 표시
    }

    world.removeBody(stone.userData.body);
    scene.remove(stone);

    // players 배열에서 제거
    players[owner].stones = players[owner].stones.filter(s => s !== stone);

    // stones 배열에서 제거
    const stoneIndex = stones.indexOf(stone);
    if (stoneIndex > -1) {
        stones.splice(stoneIndex, 1);
    };
};

/* ====== 턴 종료 처리 ====== */
function endTurn(){
    // 승리 조건 확인
    if (players[0].stones.length === 0) {
        winnerDiv.textContent = `${players[1].name} 승리!`;
        winnerDiv.style.display = 'block';
        chargeBtn.disabled = true;
        return;
    } else if (players[1].stones.length === 0) {
        winnerDiv.textContent = `${players[0].name} 승리!`;
        winnerDiv.style.display = 'block';
        chargeBtn.disabled = true;
        return;
    }

    // 상대방 돌을 떨어뜨리지 않았을 때만 턴 전환
    if (!knockedOutOpponentStoneThisTurn) turn = 1 - turn;
    updateTurnUI();
    chargeBtn.disabled = false; // 다음 턴을 위해 '치기 준비' 버튼 활성화
}

/* ====== 리사이즈 처리 ====== */
function onWindowResize(){ 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
}

/* ====== 애니메이션 루프 ====== */
function animate(time){
    requestAnimationFrame(animate);
    
    // ====== 물리 엔진 업데이트 (고정 시간 간격) ======
    if (lastTime !== undefined) {
        const dt = (time - lastTime) / 1000;
        // 고정된 시간 간격(1/360초)으로 물리 시뮬레이션을 여러 번 실행하여 정확도를 높입니다.
        world.step(1 / 360, dt, 10);
    }
    lastTime = time;

    // forEach 대신 for 루프를 사용해야 배열이 동적으로 변경될 때 안전합니다.
    for (let i = stones.length - 1; i >= 0; i--) {
        const s = stones[i];
        if (!s) continue;

        const b = s.userData.body;
        if (b) {
            const boardHalfSize = boardSize / 2 + 0.15; // 바둑판 크기의 절반

            // 바둑판 밖으로 나가거나, 이미 떨어지고 있는 돌 처리
            const isOut = Math.abs(b.position.x) > boardHalfSize || Math.abs(b.position.z) > boardHalfSize;
            if (isOut) {
                let pos;
                if (Math.abs(b.position.x) > boardHalfSize) pos = 'x';
                else if (Math.abs(b.position.z) > boardHalfSize) pos = 'z';
                b.linearFactor.set(1, 1, 1); // Y축 이동을 허용하고,
                b.velocity.y = -2;
                b.velocity[pos] = Math.abs(b.velocity[pos]) < 0.5 ? (b.position[pos] > 0 ? 0.5 : -0.5) : b.velocity[pos]; // 바깥쪽으로 밀어내기
            }
 
            // 충분히 아래로 떨어졌으면 제거
            if (b.position.y < -0.8) {
                removeStone(s);
                continue; // 돌이 제거되었으므로 다음 루프로 넘어갑니다.
            }

            // 렌더링 반영
            s.position.copy(b.position);
            s.quaternion.copy(b.quaternion);
        }
    }

    // 턴이 진행 중일 때 모든 돌이 멈췄는지 확인
    if (isTurnPlaying && stones.every(s => !s || s.userData.body.velocity.lengthSquared() < 0.001)) {
        isTurnPlaying = false;
        setTimeout(endTurn, 500); // 잠시 후 턴 종료 처리
    }

    // 선택된 돌이 있으면 화살표 업데이트
    if (selectedStone && !isTurnPlaying) {
        // 카메라 위치에서 타겟을 바라보는 방향 벡터를 계산합니다.
        const dir = new THREE.Vector3().subVectors(controls.target, camera.position);
        dir.y = 0; // y축 값을 0으로 만들어 수평 방향만 사용합니다.
        dir.normalize();

        arrowHelper.position.copy(selectedStone.position);
        arrowHelper.setDirection(dir);
        arrowHelper.visible = true;
    } else {
        arrowHelper.visible = false;
    }

    // 충전 중일 때 게이지 바 위치 업데이트
    if (charging && selectedStone) {
        const screenPosition = selectedStone.position.clone();
        // 3D 좌표를 2D 화면 좌표로 변환
        screenPosition.project(camera);

        // 화면 좌표를 CSS 픽셀 값으로 변환
        const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;

        // 게이지 바 위치 설정 (돌 아래쪽으로)
        chargeBarContainer.style.left = `${x - chargeBarContainer.offsetWidth / 2}px`;
        chargeBarContainer.style.top = `${y + 30}px`; // 돌 아래에 여유 공간
        chargeBarContainer.style.display = 'block';
    }

    TWEENUpdate(time); // Tween.js 업데이트
    controls.update(); // 카메라 컨트롤
    renderer.render(scene,camera); // 메인 렌더링
    miniRenderer.render(scene,miniCamera); // 미니맵 렌더링
}

/* ====== 실행 ====== */
init(); // 초기화
animate(); // 애니메이션 시작
</script>
</body>
</html>